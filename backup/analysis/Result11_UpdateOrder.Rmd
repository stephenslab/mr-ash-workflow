---
title: "Result11_UpdateOrder"
output:
  workflowr::wflow_html:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This .Rmd file is to plot results for the experiment of MR.ASH's internal setting.

A list of update orders we consider is as follows.

(1) `random`: In each outer loop iteration, we sample a permuation map $\xi:\{1,\cdots,p\} \to \{1,\cdots,p\}$ uniformly at random and run inner loop iterations with the order based on $\xi$.

(2) `increasing`: $(1,\cdots,p)$, i.e. in each outer loop iteration, we update $q_1,q_2,\cdots,q_p$ in this order.

(3) `lasso.pathorder`: we update $q_j$ prior to $q_{j'}$ when $\beta_j$ appears earlier than $\beta_{j'}$ in the lasso path. If ties occur, then `increasing` order applies to those ties.

(4) `scad.pathorder`: we update $q_j$ prior to $q_{j'}$ when $\beta_j$ appears earlier than $\beta_{j'}$ in the scad path. If ties occur, then `increasing` order applies to those ties.

(5) `lasso.absorder`: we update $q_j$ prior to $q_{j'}$ when the lasso solution satisfies $\hat\beta_j \geq \hat\beta_{j'}$. If ties occur, then `increasing` order applies to those ties.

(6) `univar.absorder`: we update $q_j$ prior to $q_{j'}$ when the univariate linear regression solution satisfies $\hat\beta_j \geq \hat\beta_{j'}$. If ties occur, then `increasing` order applies to those ties.

### Design setting

We sample the equicorrelated Gaussian measurement $X_{ij} \sim N(0,\Sigma)$ where $\Sigma$ has diagonal entries $1$ and off-diagonal entries $\rho$. 

The we construct $X \in \mathbb{R}^p$ with $n = 500$ and $p = 2000$.

### rho

We will use $\rho = 0.95$. In this case, MR.ASH with a default setting (i.e. the `null` intiailization and the `increasing` update order) does not outperform.

Indeed, using this simulation setting and $\rho > 0.5$, E-ENET, SCAD, and MCP performs better than MR.ASH.

### Signal setting

We sample the i.i.d. normal coefficients $\beta_j \sim N(0,\sigma_\beta^2)$ for $j \in J$ and $\beta_ j = 0$ otherwise, where $J$ is a set of randomly $s$ indices in $\{1,â‹¯,p\}$c hosen uniformly at random.

This signal will be called `sparsenormal`.

We fix $s = 20$ throughout this experiment.

### PVE

Then we sample $y = X\beta + \epsilon$, where $\epsilon \sim N(0,\sigma^2 I_n)$.

We fix PVE = 0.5, where PVE is the proportion of variance explained, defined by

$$
{\rm PVE} = \frac{\textrm{Var}(X\beta)}{\textrm{Var}(X\beta) + \sigma^2},
$$
where $\textrm{Var}(a)$ denotes the sample variance of $a$ calculated using R function `var`. To this end, we set $\sigma^2 = \textrm{Var}(X\beta)$.

### Performance Measure

The above two figures display the prediction error. The prediction error we define here is

$$
\textrm{Pred.Err}(\hat\beta;y_{\rm test}, X_{\rm test}) = \frac{\textrm{RMSE}}{\sigma} = \frac{\|y_{\rm test} - X_{\rm test} \hat\beta \|}{\sqrt{n}\sigma}
$$
where $y_{\rm test}$ and $X_{\rm test}$ are test data sample in the same way. If $\hat\beta$ is fairly accurate, then we expect that $\rm RMSE$ is similar to $\sigma$. Therefore in average $\textrm{Pred.Err} \geq 1$ and the smaller the better.

### Packages / Libraries

A list of packages we have loaded is collapsed. Please click "code" to see the list.

```{r library, message = FALSE}
library(Matrix); library(ggplot2); library(cowplot); library(susieR); library(BGLR);
library(glmnet); library(mr.ash.alpha); library(ncvreg); library(L0Learn); library(varbvs);
standardize = FALSE
source('code/method_wrapper.R')
source('code/sim_wrapper.R')
```

## Results 

```{r fig1, fig.height=13, fig.width=15}
res_df       = readRDS("../results/updateorder500200020.RDS")
method_list  = c("Mr.ASH","VarBVS","BayesB","Blasso","SuSiE","E-NET","Lasso","Ridge","SCAD","MCP","L0Learn",
                 "Mr.ASH.order","Mr.ASH.init")
method_level = c("Mr.ASH","Mr.ASH.order","Mr.ASH.init","E-NET","Lasso","Ridge",
                 "SCAD","MCP","L0Learn",
                 "VarBVS","BayesB","Blasso","SuSiE")
rho_list     = c(0,0.3,0.6,0.9,0.95,0.99)
a            = c(1,2,3,4,5,6)
ind          = 1:7
out = matrix(0,6,7)
for (i in 1:6) {
  out[i,] = colMeans(matrix(res_df[[a[i]]]$pred, 100, 7))
}
colnames(out) = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                  "lasso.abs.order","random.permute","oracle.abs.order")

col   = gg_color_hue(13)[c(1:7,12,13)]
shape = c(19,17,24,25,9,3,11,4,5,7,8,10,1)[c(1:7,12,13)]
df = data.frame(x = rep(1:length(rho_list),length(ind)), rho = rep(rho_list, length(ind)),
                pred = c(out), fit = rep(colnames(out), each = length(rho_list)))
df$fit = factor(df$fit, levels = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                                   "lasso.abs.order","random.permute","oracle.abs.order")
)
fig_dummy = ggplot(df) + geom_line(aes(x = x, y = pred, color = fit)) +
  geom_point(aes(x = x, y = pred, color = fit, shape = fit), size = 2.5) +
  theme_cowplot(font_size = 14) +
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                     labels = c("0","0.3","0.6","0.9","0.95","0.99")) +
  labs(y = "predictior error (rmse / sigma)", x = "correlation across columns of X (rho)") +
  theme(axis.line = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = col) +
  scale_shape_manual(values = shape) +
  scale_y_continuous(trans = "log10", breaks = c(1,1.05,1.1,1.15,1.2,1.25,1.3,1.4)) +
  coord_cartesian(ylim = c(1,1.12))
p1        = fig_dummy + theme(legend.position = "none")
fig_main  = p1
subtitle  = ggdraw() + draw_label("Scenario: EquiCorrGauss + Normal, n = 500, p = 200, s = 20, pve = 0.5", fontface  = 'bold', size = 14) 
fig1.1      = plot_grid(subtitle,p1, ncol = 1, rel_heights = c(0.05,0.95))
```

```{r fig2, fig.height=13, fig.width=15}
res_df       = readRDS("../results/updateorder50020020.RDS")
method_list  = c("Mr.ASH","VarBVS","BayesB","Blasso","SuSiE","E-NET","Lasso","Ridge","SCAD","MCP","L0Learn",
                 "Mr.ASH.order","Mr.ASH.init")
method_level = c("Mr.ASH","Mr.ASH.order","Mr.ASH.init","E-NET","Lasso","Ridge",
                 "SCAD","MCP","L0Learn",
                 "VarBVS","BayesB","Blasso","SuSiE")
rho_list     = c(0,0.3,0.6,0.9,0.95,0.99)
a            = c(1,2,3,4,5,6)
ind          = 1:7
out = matrix(0,6,7)
for (i in 1:6) {
  out[i,] = -colMeans(matrix(res_df[[a[i]]]$vobj, 100, 7) - matrix(res_df[[a[i]]]$vobj, 100, 7)[,6])
}
colnames(out) = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                  "lasso.abs.order","random.permute","oracle.abs.order")

col   = gg_color_hue(13)[c(1:7,12,13)]
shape = c(19,17,24,25,9,3,11,4,5,7,8,10,1)[c(1:7,12,13)]
df = data.frame(x = rep(1:length(rho_list),length(ind)), rho = rep(rho_list, length(ind)),
                vobj = c(out), fit = rep(colnames(out), each = length(rho_list)))
df$fit = factor(df$fit, levels = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                                   "lasso.abs.order","random.permute","oracle.abs.order")
)
fig_dummy = ggplot(df) + geom_line(aes(x = x, y = vobj, color = fit)) +
  geom_point(aes(x = x, y = vobj, color = fit, shape = fit), size = 2.5) +
  theme_cowplot(font_size = 14) +
  scale_x_continuous(breaks = c(1,2,3,4,5,6),
                     labels = c("0","0.3","0.6","0.9","0.95","0.99")) +
  labs(y = "predictior error (rmse / sigma)", x = "correlation across columns of X (rho)") +
  theme(axis.line = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = col) +
  scale_shape_manual(values = shape)
p1        = fig_dummy + theme(legend.position = "none")
fig_main  = p1
subtitle  = ggdraw() + draw_label("Scenario: EquiCorrGauss + Normal, n = 500, p = 200, s = 20, pve = 0.5", fontface  = 'bold', size = 14) 
fig1.2      = plot_grid(subtitle,fig_dummy, ncol = 1, rel_heights = c(0.05,0.95))
```

## Source Code

```{r code, eval = FALSE}
library(Matrix); library(ggplot2); library(cowplot); library(susieR); library(BGLR);
library(glmnet); library(mr.ash.alpha); library(ncvreg); library(L0Learn); library(varbvs);
standardize = FALSE
source('code/method_wrapper.R')
source('code/sim_wrapper.R')

tdat1        = list()
n            = 500
p            = 200
s            = 20
sa2          = (2^((0:19) / 5) - 1)^2
method_list  = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                 "lasso.abs.order","random.permute","oracle.abs.order")
method_num   = length(method_list)
iter_num     = 100
pred         = matrix(0, iter_num, method_num); colnames(pred) = method_list
time         = matrix(0, iter_num, method_num); colnames(time) = method_list
numiter      = matrix(0, iter_num, method_num); colnames(numiter) = method_list
vobj         = matrix(0, iter_num, method_num); colnames(vobj) = method_list
rho_list     = c(0,0.3,0.6,0.9,0.95,0.99)

for (iter in 1:6) {
  rho           = rho_list[iter]
for (i in 1:iter_num) {
  data          = simulate_data(n, p, s = s, seed = i, signal = "normal", rho = rho,
                                design = "equicorrgauss", pve = 0.5)
  X             = data$X
  y             = data$y
  
  fit1             <- fit.lasso(data$X, data$y, data$X.test, data$y.test, seed = i)
  fit2             <- fit.scad2(data$X, data$y, data$X.test, data$y.test, seed = i)
  lasso.path.order = mr.ash.alpha:::path.order(fit1$fit$glmnet.fit)
  lasso.beta       = as.vector(coef(fit1$fit))[-1]
  lasso.time       = c(fit1$t, fit1$t2)
  lasso.abs.order  = mr.ash.alpha:::abs.order(lasso.beta)
  scad.path.order  = mr.ash.alpha:::path.order(fit2$fit$fit)
  scad.beta        = as.vector(coef(fit2$fit))[-1]
  scad.time        = c(fit2$t, fit2$t2)
  univ.abs.order   = mr.ash.alpha:::abs.order(c(t(X) %*% y) / c(colMeans(X^2)))
  oracle.abs.order = mr.ash.alpha:::abs.order(data$beta)
  
  t.mrash1          = system.time(
    fit.mrash1       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  
  t.mrash2          = system.time(
    fit.mrash2       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = scad.path.order,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  t.mrash3          = system.time(
    fit.mrash3       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = lasso.path.order,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  t.mrash4          = system.time(
    fit.mrash4       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = univ.abs.order,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  t.mrash5          = system.time(
    fit.mrash5       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = lasso.abs.order,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  t.mrash6          = system.time(
    fit.mrash6       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = "random",
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  t.mrash7          = system.time(
    fit.mrash7       <- mr.ash(X = X, y = y, sa2 = sa2,
                               max.iter = 2000, update.order = oracle.abs.order,
                               standardize = standardize,
                               tol = list(epstol = 1e-12, convtol = 1e-8)))
  
  for (j in 1:7) {
    fit           = get(paste("fit.mrash",j,sep = ""))
    pred[i,j]     = norm(data$y.test - predict(fit, data$X.test), '2') / sqrt(500) / data$sigma
    numiter[i,j]  = fit$iter
    vobj[i,j]     = fit$varobj[fit$iter]
    time[i,j]     = get(paste("t.mrash",j,sep = ""))[3]
  }
  
  print(c(vobj[i,]))
}
tdat1[[iter]] = data.frame(pred = c(pred), vobj = c(vobj), time = c(time),
                           numiter = c(numiter),
                           order = rep(method_list, each = iter_num))
}
```

```{r code2, eval = FALSE}
library(Matrix); library(ggplot2); library(cowplot); library(susieR); library(BGLR);
library(glmnet); library(mr.ash.alpha); library(ncvreg); library(L0Learn); library(varbvs);
standardize = FALSE
source('code/method_wrapper.R')
source('code/sim_wrapper.R')
tdat2        = list()
n            = 500
p            = 2000
s            = 20
sa2          = (2^((0:19) / 5) - 1)^2
method_list  = c("random.fixed","scad.path.order","lasso.path.order","univ.abs.order",
                 "lasso.abs.order","random.permute","oracle.abs.order")
method_num   = length(method_list)
iter_num     = 100
pred         = matrix(0, iter_num, method_num); colnames(pred) = method_list
time         = matrix(0, iter_num, method_num); colnames(time) = method_list
numiter      = matrix(0, iter_num, method_num); colnames(numiter) = method_list
vobj         = matrix(0, iter_num, method_num); colnames(vobj) = method_list
rho_list     = c(0,0.3,0.6,0.9,0.95,0.99)

for (iter in 1:6) {
  rho           = rho_list[iter]
  for (i in 1:iter_num) {
    data          = simulate_data(n, p, s = s, seed = i, signal = "normal", rho = rho,
                                  design = "equicorrgauss", pve = 0.5)
    X             = data$X
    y             = data$y
    
    fit1             <- fit.lasso(data$X, data$y, data$X.test, data$y.test, seed = i)
    fit2             <- fit.scad2(data$X, data$y, data$X.test, data$y.test, seed = i)
    lasso.path.order = mr.ash.alpha:::path.order(fit1$fit$glmnet.fit)
    lasso.beta       = as.vector(coef(fit1$fit))[-1]
    lasso.time       = c(fit1$t, fit1$t2)
    lasso.abs.order  = mr.ash.alpha:::abs.order(lasso.beta)
    scad.path.order  = mr.ash.alpha:::path.order(fit2$fit$fit)
    scad.beta        = as.vector(coef(fit2$fit))[-1]
    scad.time        = c(fit2$t, fit2$t2)
    univ.abs.order   = mr.ash.alpha:::abs.order(c(t(X) %*% y) / c(colMeans(X^2)))
    oracle.abs.order = mr.ash.alpha:::abs.order(data$beta)
    
    t.mrash1          = system.time(
      fit.mrash1       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    
    t.mrash2          = system.time(
      fit.mrash2       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = scad.path.order,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    t.mrash3          = system.time(
      fit.mrash3       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = lasso.path.order,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    t.mrash4          = system.time(
      fit.mrash4       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = univ.abs.order,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    t.mrash5          = system.time(
      fit.mrash5       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = lasso.abs.order,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    t.mrash6          = system.time(
      fit.mrash6       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = "random",
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    t.mrash7          = system.time(
      fit.mrash7       <- mr.ash(X = X, y = y, sa2 = sa2,
                                 max.iter = 2000, update.order = oracle.abs.order,
                                 standardize = standardize,
                                 tol = list(epstol = 1e-12, convtol = 1e-8)))
    
    for (j in 1:7) {
      fit           = get(paste("fit.mrash",j,sep = ""))
      pred[i,j]     = norm(data$y.test - predict(fit, data$X.test), '2') / sqrt(500) / data$sigma
      numiter[i,j]  = fit$iter
      vobj[i,j]     = fit$varobj[fit$iter]
      time[i,j]     = get(paste("t.mrash",j,sep = ""))[3]
    }
    
    print(c(vobj[i,]))
  }
  tdat2[[iter]] = data.frame(pred = c(pred), vobj = c(vobj), time = c(time),
                             numiter = c(numiter),
                             order = rep(method_list, each = iter_num))
}
```